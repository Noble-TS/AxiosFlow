import axios, { AxiosError, isAxiosError } from 'axios';
import * as dotenv from 'dotenv';
import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';
import prettier from 'prettier';
dotenv.config();

// Get the directory name in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// interface for endpoint properties
interface EndpointProperty {
    type: string;
    description?: string;
    optional?: boolean;
    example?: any;
}
// interface for endpoints
interface Endpoints {
    method: string;
    path: string;
    description?: string;
    request?: {
        name: string,
        properties: Record<string, EndpointProperty>
    } | null;
    response?: {
        name: string,
        properties: Record<string, EndpointProperty>
    } | null;
}
// interface for type generation options
interface TypeGenerationOptions {
    includeResponseTypes?: boolean;
    includeRequestTypes?: boolean;
}
// interface for schemas
interface Schemas {
    baseUrl: string;
    endpoints: Record<string, Record<string, Endpoints>>;
}

// Utility function to generate function name
const generateFunctionName = (method: string, path: string): string => {
    return `${method.toLowerCase()}${path.replace(/\//g, '_').replace(/:/g, '')}`;
};

// Utility function to generate function hints
const generateFunctionHints = (endpoint: Endpoints, functionName: string): string[] => {
    const hints: string[] = [];

    hints.push(`Performs a ${endpoint.method.toUpperCase()} request to ${endpoint.path}`);

    if (endpoint.description) {
        hints.push(`${endpoint.description}`);
    }

    // Request type
    if (endpoint.request?.properties) {
        const paramHints = Object.entries(endpoint.request.properties)
            .map(([key, details]) => {
                let hint = `@param {${details.type}${details.optional ? ' | undefined' : ''}} data.${key}`;

                if (details.description) {
                    hint += ` - ${details.description}`;
                }

                if (details.example !== undefined) {
                    hint += ` (e.g., ${JSON.stringify(details.example)})`;
                }

                return hint;
            });
        hints.push(...paramHints);
    }

    // Axios request configuration
    hints.push('@param {AxiosRequestConfig} [config] - Optional Axios request configuration');

    // Response type
    if (endpoint.response?.name) {
        hints.push(`@returns {Promise<${endpoint.response.name}>} - ${endpoint.response.name} response data`);
    }

    // Error handling
    hints.push('@throws {Error} - Throws an error for network or API-related issues');

    // Example usage hint for generated function
    hints.push('@example');

    const exampleParams = endpoint.request?.properties
        ? Object.entries(endpoint.request.properties)
            .filter(([_, details]) => !details.optional)
            .map(([key, details]) => {
                const exampleValue = details.example !== undefined
                    ? JSON.stringify(details.example)
                    : `"example ${key}"`;
                return `${key}: ${exampleValue}`;
            })
            .join(', ')
        : '';

    hints.push(` * const result = await ${functionName}(${exampleParams ? `{ ${exampleParams} }` : ''});`);

    return hints;
};

/** Utility function to generate function name
 * @param schema 
 * @returns 
 */
const generateTypes = (
    schema: any,
    options: TypeGenerationOptions = {
        includeResponseTypes: true,
        includeRequestTypes: true
    }
): string => {
    const typeLines: string[] = [
        "/**",
        " * Auto-generated types based on API schema",
        " * Generated by axiosflow",
        " * @generated",
        " * @timestamp " + new Date().toISOString(),
        " */"
    ];

    // Track generated type names to prevent duplicates
    const generatedTypeNames = new Set<string>();

    // Generate types for each endpoint
    Object.entries(schema.endpoints || {}).forEach(([, methods]) => {
        Object.entries(methods as Record<string, any>).forEach(([, endpoint]) => {
            // Generate response types
            if (options.includeResponseTypes &&
                endpoint.response &&
                endpoint.response.name &&
                endpoint.response.properties
            ) {
                const typeName = endpoint.response.name;
                // Prevent duplicate type generation 
                if (!generatedTypeNames.has(typeName)) {
                    const propertiesLines = Object.entries(endpoint.response.properties)
                        .map(([key, type]) => `${key}: ${type};`)
                        .join('\n    ');

                    typeLines.push(`
export interface ${typeName} {
    ${propertiesLines}
}`);
                    generatedTypeNames.add(typeName);
                }
            }

            // Generate request types
            if (options.includeRequestTypes &&
                endpoint.request &&
                endpoint.request.name &&
                endpoint.request.properties
            ) {
                const typeName = endpoint.request.name;

                // Prevent duplicate type generation
                if (!generatedTypeNames.has(typeName)) {
                    const propertiesLines = Object.entries(endpoint.request.properties)
                        .map(([key, type]) => `${key}: ${type};`)
                        .join('\n    ');

                    typeLines.push(`
export interface ${typeName} {
    ${propertiesLines}
}`);
                    generatedTypeNames.add(typeName);
                }
            }
        });
    });

    return typeLines.join('\n\n');
};

// Generate API functions
export const generateApiFunctions = async (schema: Schemas): Promise<string> => {
    const functionLines: string[] = [
        "/**",
        " * Auto-generated types based on API schema",
        " * Generated by axiosflow",
        " * @generated",
        " * @timestamp " + new Date().toISOString(),
        " */",
        "import axios, { AxiosRequestConfig, isAxiosError } from 'axios';",
        "import { BASE_URL, endpoints } from './apiConfig';\n"
    ];

    // Track request and response types
    const requestTypes = new Set<string>();
    const responseTypes = new Set<string>();
    Object.entries(schema.endpoints).forEach(([_path, methods]) => {
        Object.entries(methods).forEach(([_method, endpoint]) => {
            if (endpoint.request && endpoint.request.name) requestTypes.add(endpoint.request.name);
            if (endpoint.response && endpoint.response.name) responseTypes.add(endpoint.response.name);
        });
    });

    // Import types if needed
    if (requestTypes.size > 0 || responseTypes.size > 0) {
        functionLines.push(`import { ${[...requestTypes, ...responseTypes].join(', ')
            } } from './types';\n`);
    }

    // Generate functions for each endpoint
    Object.entries(schema.endpoints).forEach(([path, methods]) => {
        Object.entries(methods).forEach(([method, endpoint]) => {
            // Generate function name
            const functionName = generateFunctionName(method, path);

            // Determine parameter and return types
            const paramType = endpoint.request && endpoint.request.name
                ? endpoint.request.name
                : 'Record<string, unknown>';
            const returnType = endpoint.response && endpoint.response.name
                ? endpoint.response.name
                : 'unknown';

            // Generate comprehensive hints for the function
            const hints = generateFunctionHints(endpoint, functionName);
            const commentBlock = hints.map(hint => ` * ${hint}`).join('\n');

            // Generate the function code block with hints and comments 
            functionLines.push(`
                /**
                 * ${commentBlock}
                 */
                export const ${functionName} = async (
                    data${path.includes(':') ? '' : '?'}: ${paramType}, 
                    config?: AxiosRequestConfig
                ): Promise<${returnType}> => {
                    // URL parameter replacement utility
                    const replaceUrlParams = (url: string, data?: ${paramType}) => {
                        if (!data) return url;
                        return url.replace(/:(\\w+)/g, (_, key) => 
                            data[key as keyof typeof data] !== undefined 
                                ? String(data[key as keyof typeof data]) 
                                : ''
                        );
                    };

                    // Construct base URL
                    const baseUrl = BASE_URL + endpoints.${functionName};
                    
                    // Replace URL parameters
                    const url = replaceUrlParams(baseUrl, data);
                    
                    const requestConfig: AxiosRequestConfig = {
                        method: '${method.toUpperCase()}',
                        url,
                        ${method.toLowerCase() !== 'get' ? 'data,' : 'params: data,'}
                        ...config
                    };

                    try {
                        console.log('Requesting:', requestConfig);
                        const response = await axios(requestConfig);
                        console.log('Response:', response.data);
                        return response.data;
                    } catch (error) {
                        if (isAxiosError(error)) {
                            console.error('Axios Error:', error.message);
                            throw new Error(
                                error.response?.data?.message || 
                                error.message || 
                                'An unexpected error occurred'
                            );
                        }
                        console.error('General Error:', error);
                        throw error;
                    }
                };`);
        });
    });
    // Combine all function lines
    const combinedCode = functionLines.join('\n\n');

    // Format the code using Prettier 
    try {
        const formattedCode = await prettier.format(combinedCode, {
            parser: 'typescript',
            singleQuote: true,
            trailingComma: 'es5',
            tabWidth: 4,
            semi: true,
            printWidth: 100,
            arrowParens: 'avoid',
            bracketSpacing: true,
            endOfLine: 'lf',
        });

        return formattedCode; // Return formatted code
    } catch (error) {
        console.error('Error formatting code:', error);
        return combinedCode; // Fallback to unformatted code
    }
};

// Generate API config file with base URL and endpoints
export const generateApiUrls = (schema: Schemas): string => {
    const configLines: string[] = [
        `export const BASE_URL = '${schema.baseUrl}/api';\n`,
        'export const endpoints = {'
    ];

    Object.entries(schema.endpoints).forEach(([path, methods]) => {
        Object.entries(methods).forEach(([method]) => {
            const functionName = generateFunctionName(method, path);
            configLines.push(`    ${functionName}: '${path}',`);
        });
    });
    configLines.push('};\n');
    return configLines.join('\n');
};

// Generate API functions and types from API schema 
export const generateFunctions = async () => {
    const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
    try {
        console.log('Fetching API routes...');
        const response = await axios.get(`${baseUrl}/api/routes`);
        const routes: Endpoints[] = response.data;
        console.log('API routes fetched:', routes);
        const apiSchema: Schemas = {
            baseUrl,
            endpoints: {},
        };

        routes.forEach(({ method, path, request, response }) => {
            if (!apiSchema.endpoints[path]) {
                apiSchema.endpoints[path] = {};
            }
            apiSchema.endpoints[path][method] = {
                method,
                path,
                request: request || undefined,
                response: response || undefined
            };
        });

        // Create the services directory if it doesn't exist
        const servicesDir = path.resolve(__dirname, '../../src/services');
        await fs.mkdir(servicesDir, { recursive: true });

        // Generate API schema
        const schemaPath = path.resolve(servicesDir, 'api-schema.json');
        await fs.writeFile(schemaPath, JSON.stringify(apiSchema, null, 2));
        console.log('API schema generated at:', schemaPath);

        // Generate TypeScript types 
        const typesOutput = generateTypes(apiSchema);
        const typesPath = path.resolve(servicesDir, 'types.ts');
        await fs.writeFile(typesPath, typesOutput);
        console.log('TypeScript types generated at:', typesPath);

        // Generate API functions
        const functionOutput = generateApiFunctions(apiSchema);
        const functionsPath = path.resolve(servicesDir, 'apiFunctions.ts');
        await fs.writeFile(functionsPath, await functionOutput);
        console.log('TypeScript functions generated at:', functionsPath);

        // Generate API config
        const configOutput = generateApiUrls(apiSchema);
        const configPath = path.resolve(servicesDir, 'apiConfig.ts');
        await fs.writeFile(configPath, configOutput);
        console.log('API config generated at:', configPath);

        return apiSchema;
    } catch (error: unknown) {

        if (isAxiosError(error)) {
            const axiosError = error as AxiosError;
            console.error('Axios Error:', {
                message: axiosError.message,
                status: axiosError.response?.status,
                data: axiosError.response?.data
            });
        } else if (error instanceof Error) {
            console.error('Error:', error.message);
        } else {
            console.error('Unknown error:', String(error));
        }
        throw error;
    }
};

// Run the script if called directly from the command line 
if (import.meta.url === `file://${__filename}`) {
    try {
        await generateFunctions();
        console.log('API functions generated successfully');
        process.exit(0);
    } catch (error) {
        console.error('Failed to generate API functions:', error);
        process.exit(1);
    }
}